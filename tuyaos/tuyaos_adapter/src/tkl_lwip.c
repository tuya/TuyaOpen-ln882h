/**
 * @file tkl_lwip.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */

// --- BEGIN: user defines and implements ---
#include "tkl_lwip.h"
#include "tuya_error_code.h"
#include "log.h"
#include "freertos_common.h"
#include "tkl_wifi.h"
#include "lwip/ethernetif.h"
// --- END: user defines and implements ---

#if ENABLE_LN_LWIP
#include "lwip/pbuf.h"
#include "lwip/netif.h"

typedef enum {
    NETIF_STA_IDX = 0,
    NETIF_AP_IDX,
    NETIF_NUM
} TUYA_NETIF_TYPE;

typedef struct {
    ip4_addr_t ip;
    ip4_addr_t netmask;
    ip4_addr_t gw;
} ty_netif_ip_info_s;
#endif // ENABLE_LN_LWIP

struct netif *tkl_lwip_get_netif_by_index(int net_if_idx)
{
    if(net_if_idx == 0)
        return netdev_get_netif(0);
    else if(net_if_idx == 1)
        return netdev_get_netif(1);

    return NULL;
}

struct netif *netdev_get(void)
{
    WF_WK_MD_E mode;
    TUYA_NETIF_TYPE net_if_idx;

    tkl_wifi_get_work_mode(&mode);
    switch (mode) {
        case WWM_SOFTAP:
            net_if_idx = NETIF_AP_IDX;
            break;
        case WWM_SNIFFER:
        case WWM_STATION:
        case WWM_STATIONAP:
            net_if_idx = NETIF_STA_IDX;
            break;
        case WWM_POWERDOWN:
        case WWM_UNKNOWN:
        default:
            return NULL;
    }

    struct netif *nif = tuya_ethernetif_get_netif_by_index(net_if_idx);
    if (nif == NULL)
        return;

    return nif;
}

static void netif_low_level_input_callback(uint8_t *data, uint16_t len)
{
    WF_WK_MD_E mode;
    TUYA_NETIF_TYPE net_if_idx;
    struct pbuf *pkt = NULL, *q = NULL;

    struct netif *nif = netdev_get();
    if (nif == NULL)
        return;

    pkt = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
    if(NULL == pkt) {
        LOG(LOG_LVL_DEBUG, "[%s, %d] Can not malloc pbuff(request len=%d).\r\n", __func__, __LINE__, len);
        return;
    }

    for(q = pkt; q != NULL; q = q->next) {
        memcpy(q->payload, data, q->len);
        data += q->len;
    }

    if(nif->input(pkt, nif) != ERR_OK) {
        pbuf_free(pkt);
    }
}

/**
 * @brief ethernet interface hardware init
 *
 * @param[in]      netif     the netif to which to send the packet
 * @return  err_t  SEE "err_enum_t" in "lwip/err.h" to see the lwip err(ERR_OK: SUCCESS other:fail)
 */
OPERATE_RET tkl_ethernetif_init(TKL_NETIF_HANDLE netif)
{
    struct netif *p_netif = (struct netif *)netif;

    LOG(LOG_LVL_INFO, "tkl_ethernetif_init\r\n");
    //p_netif->flags |= NETIF_FLAG_LINK_UP;

    wifi_if_reg_recv_ethernet_pkt_callback(&netif_low_level_input_callback);
    return OPRT_OK;
}

/**
 * @brief ethernet interface sendout the pbuf packet
 *
 * @param[in]      netif     the netif to which to send the packet
 * @param[in]      p         the packet to be send, in pbuf mode
 * @return  err_t  SEE "err_enum_t" in "lwip/err.h" to see the lwip err(ERR_OK: SUCCESS other:fail)
 */
OPERATE_RET tkl_ethernetif_output(TKL_NETIF_HANDLE netif, TKL_PBUF_HANDLE p)
{
    err_enum_t ret = ERR_OK;

    struct pbuf *q = NULL;
    struct pbuf *pkt = (struct pbuf *)p;
    uint8_t * frame_buf  = NULL;
    uint16_t payload_offset = 0;

    if(!netif_is_link_up((struct netif *)netif)) {
        LOG(LOG_LVL_INFO, "[%s, %d] netif is not link up.\r\n", __func__, __LINE__);
        ret = ERR_IF;
        return ret;
    }

    frame_buf = OS_Malloc(pkt->tot_len);
    if (frame_buf == NULL)
    {
        ret = ERR_MEM;
        return ret;
    }

    for(q = pkt; q != NULL; q = q->next) {
        memcpy(frame_buf + payload_offset, (u8_t*)q->payload, q->len );
        payload_offset += q->len;
    }
    wifi_send_ethernet_pkt(frame_buf, pkt->tot_len, 20, 5);

    OS_Free(frame_buf);
    return OPRT_OK;
}

/**
 * @brief ethernet interface recv the packet
 *
 * @param[in]      netif       the netif to which to recieve the packet
 * @param[in]      total_len   the length of the packet recieved from the netif
 * @return  void
 */
OPERATE_RET tkl_ethernetif_recv(TKL_NETIF_HANDLE netif, TKL_PBUF_HANDLE p)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

